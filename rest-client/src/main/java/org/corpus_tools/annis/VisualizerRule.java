/*
 * graphANNIS
 * Access the graphANNIS corpora and execute AQL queries with this service. 
 *
 * OpenAPI spec version: 0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.corpus_tools.annis;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * A rule when to trigger a visualizer for a specific result.
 */
@Schema(description = "A rule when to trigger a visualizer for a specific result.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-06-24T14:51:23.486442+02:00[Europe/Berlin]")
public class VisualizerRule {
  /**
   * On which element type to trigger the visualizer on
   */
  @JsonAdapter(ElementEnum.Adapter.class)
  public enum ElementEnum {
    NODE("node"),
    EDGE("edge");

    private String value;

    ElementEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ElementEnum fromValue(String text) {
      for (ElementEnum b : ElementEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ElementEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ElementEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ElementEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ElementEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("element")
  private ElementEnum element = null;

  @SerializedName("layer")
  private String layer = null;

  @SerializedName("vis_type")
  private String visType = null;

  @SerializedName("display_name")
  private String displayName = null;

  /**
   * The default display state of the visualizer before any user interaction.
   */
  @JsonAdapter(VisibilityEnum.Adapter.class)
  public enum VisibilityEnum {
    HIDDEN("hidden"),
    VISIBLE("visible"),
    PERMANENT("permanent"),
    PRELOADED("preloaded"),
    REMOVED("removed");

    private String value;

    VisibilityEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static VisibilityEnum fromValue(String text) {
      for (VisibilityEnum b : VisibilityEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<VisibilityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VisibilityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VisibilityEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return VisibilityEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("visibility")
  private VisibilityEnum visibility = null;

  @SerializedName("mappings")
  private Object mappings = null;

  public VisualizerRule element(ElementEnum element) {
    this.element = element;
    return this;
  }

   /**
   * On which element type to trigger the visualizer on
   * @return element
  **/
  @Schema(description = "On which element type to trigger the visualizer on")
  public ElementEnum getElement() {
    return element;
  }

  public void setElement(ElementEnum element) {
    this.element = element;
  }

  public VisualizerRule layer(String layer) {
    this.layer = layer;
    return this;
  }

   /**
   * In which layer the element needs to be part of to trigger this visualizer.  Only relevant for edges, since only they are part of layers. If not given, elements of all layers trigger this visualization. 
   * @return layer
  **/
  @Schema(description = "In which layer the element needs to be part of to trigger this visualizer.  Only relevant for edges, since only they are part of layers. If not given, elements of all layers trigger this visualization. ")
  public String getLayer() {
    return layer;
  }

  public void setLayer(String layer) {
    this.layer = layer;
  }

  public VisualizerRule visType(String visType) {
    this.visType = visType;
    return this;
  }

   /**
   * The abstract type of visualization, e.g. \&quot;tree\&quot;, \&quot;discourse\&quot;, \&quot;grid\&quot;, ...
   * @return visType
  **/
  @Schema(description = "The abstract type of visualization, e.g. \"tree\", \"discourse\", \"grid\", ...")
  public String getVisType() {
    return visType;
  }

  public void setVisType(String visType) {
    this.visType = visType;
  }

  public VisualizerRule displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

   /**
   * A text displayed to the user describing this visualization
   * @return displayName
  **/
  @Schema(description = "A text displayed to the user describing this visualization")
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }

  public VisualizerRule visibility(VisibilityEnum visibility) {
    this.visibility = visibility;
    return this;
  }

   /**
   * The default display state of the visualizer before any user interaction.
   * @return visibility
  **/
  @Schema(description = "The default display state of the visualizer before any user interaction.")
  public VisibilityEnum getVisibility() {
    return visibility;
  }

  public void setVisibility(VisibilityEnum visibility) {
    this.visibility = visibility;
  }

  public VisualizerRule mappings(Object mappings) {
    this.mappings = mappings;
    return this;
  }

   /**
   * Additional configuration given as generic map of key values to the visualizer.
   * @return mappings
  **/
  @Schema(description = "Additional configuration given as generic map of key values to the visualizer.")
  public Object getMappings() {
    return mappings;
  }

  public void setMappings(Object mappings) {
    this.mappings = mappings;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VisualizerRule visualizerRule = (VisualizerRule) o;
    return Objects.equals(this.element, visualizerRule.element) &&
        Objects.equals(this.layer, visualizerRule.layer) &&
        Objects.equals(this.visType, visualizerRule.visType) &&
        Objects.equals(this.displayName, visualizerRule.displayName) &&
        Objects.equals(this.visibility, visualizerRule.visibility) &&
        Objects.equals(this.mappings, visualizerRule.mappings);
  }

  @Override
  public int hashCode() {
    return Objects.hash(element, layer, visType, displayName, visibility, mappings);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VisualizerRule {\n");
    
    sb.append("    element: ").append(toIndentedString(element)).append("\n");
    sb.append("    layer: ").append(toIndentedString(layer)).append("\n");
    sb.append("    visType: ").append(toIndentedString(visType)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    visibility: ").append(toIndentedString(visibility)).append("\n");
    sb.append("    mappings: ").append(toIndentedString(mappings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
