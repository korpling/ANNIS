<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ANNIS Help</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="interface.html"><strong aria-hidden="true">1.</strong> Using the ANNIS interface</a></li><li><ol class="section"><li><a href="interface-search-form.html"><strong aria-hidden="true">1.1.</strong> Search Form</a></li><li><a href="interface-result-window.html"><strong aria-hidden="true">1.2.</strong> Result Window</a></li><li><a href="interface-query-builder.html"><strong aria-hidden="true">1.3.</strong> Query Builder</a></li></ol></li><li><a href="aql.html"><strong aria-hidden="true">2.</strong> ANNIS Query Language (AQL)</a></li><li><ol class="section"><li><a href="aql-word-forms.html"><strong aria-hidden="true">2.1.</strong> Searching for Word Forms</a></li><li><a href="aql-annotations.html"><strong aria-hidden="true">2.2.</strong> Searching for Annotations</a></li><li><a href="aql-regex.html"><strong aria-hidden="true">2.3.</strong> Searching using Regular Expressions</a></li><li><a href="aql-trees.html"><strong aria-hidden="true">2.4.</strong> Searching for Trees</a></li><li><a href="aql-pointing.html"><strong aria-hidden="true">2.5.</strong> Searching for Pointing Relations</a></li><li><a href="aql-export.html"><strong aria-hidden="true">2.6.</strong> Exporting Results</a></li><li><a href="aql-frequency.html"><strong aria-hidden="true">2.7.</strong> Frequency Analysis</a></li><li><a href="aql-operators.html"><strong aria-hidden="true">2.8.</strong> Complete List of Operators</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">ANNIS Help</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#using-the-annis-interface" id="using-the-annis-interface"><h1>Using the ANNIS interface</h1></a>
<p>The ANNIS interface is comprised of several areas, the most important of
which are the search form on the left side and the results tab on the right side.</p>
<p><img src="images/annis3_interface.png" alt="Screenshot of the ANNIS user interface" /></p>
<a class="header" href="#search-form" id="search-form"><h1>Search Form</h1></a>
<p><img src="images/searchform.png" alt="ANNIS search form" /></p>
<p>The Search Form can be found on the left of the interface window. It's
bottom part shows the list of currently available corpora. By clicking
on the line with the corpus name, it is possible to select which corpora
should be searched in (hold down 'ctrl' to select multiple corpora
simultaneously). You may also configure groups of corpora or type in the
filter box to view subsets of the corpora.</p>
<p>The &quot;AQL&quot; field at the top of the form is used for inputting queries
manually (see the tutorials on the ANNIS Query Language from the ANNIS
website). As soon as one or several corpora are selected and a query is
entered or modified, the query will be validated automatically and
possible errors in the query syntax will be commented on in the
&quot;Status&quot; box below (which says &quot;valid query&quot; in the image above).</p>
<p>Once a valid query has been entered, pressing the &quot;Search&quot; button will
retrieve the number of matching positions and documents in the selected
corpora in the Status box and open the Result tab to display the first
set of matches.</p>
<p><img src="images/searchoptions.png" alt="ANNIS search options" /></p>
<p>In order to get more control over the search you can click on &quot;Search
Options&quot; to unfold more detailed search options. The context
surrounding the matching expressions in the result list ist determined
by the &quot;Left Context&quot; and &quot;Right Context&quot; options and can be changed
on each side (by default up to 20 tokens). You can also configure how
many results are shown per page, what order results are shown in
(ascending, descending or random) and for some corpora, you can select
alternative segmentation layers to visualize data (relevant for
languages with multiple tokens per word form, etc., such as Arabic).
Entire texts can also be viewed using special document visualizations or
by clicking on the document icon next to each corpus name, if available.</p>
<a class="header" href="#result-window" id="result-window"><h1>Result Window</h1></a>
<p><img src="images/search_bar.png" alt="ANNIS result window toolbar" /></p>
<p>The result window shows search results in pages of 10 hits each by
default (this can be changed in the Search Form). The toolbar at the top
of the window allows you to navigate between these pages. The &quot;Token
Annotations&quot; button on the toolbar allows you to toggle the token based
annotations, such as lemmas and parts-of-speech, on or off for you
convenience. You can use hyperlinks to your queries by copying the
current browser URL for e-mail or citation purposes, allowing others to
reproduce your query.</p>
<p>If your corpus contains multiple alternative text layers or
segmentations (e.g. normalized and un-normalized text), you may switch
between these on the fly by using the &quot;base text&quot; menu.</p>
<p><img src="images/KWIC_narrow.png" alt="KWIC concordance in ANNIS" /></p>
<p>The result list itself initially shows a KWIC (key word in context)
concordance of matching positions in the selected corpora, with the
matching regions marked in color and the context in black on either
side. Colors in the result match the colors of search expressions in the
search box (red for the search item #1, purple for #2, etc.).</p>
<p>Context can be adjusted for individual search results up to the maximum
allowed for the current corpus. Token annotations are displayed in gray
under each token, and hovering over them with the mouse will show the
annotation name and namespace. More complex annotation levels can be
expanded, if available, by clicking on the plus icon next to the
level's name, e.g. dependencies and referent information for the
annotations in the dependency tree and grid views in the picture below.</p>
<p><img src="images/annotation_levels.png" alt="visualization of different annotation levels" /></p>
<a class="header" href="#query-builder" id="query-builder"><h1>Query Builder</h1></a>
<p>To open the graphical query builder, click on the <strong>Query Builder</strong>
button. On the left-hand side of the toolbar at the top of the query
builder canvans, you will see the <strong>Add Node</strong> button. Use this button
to define nodes to be searched for (tokens, non-terminal nodes or
annotations). Creating nodes and modifying them on the canvas will
immediately update the AQL field in the Search Form with your query,
though updating the query on the Search Form will not create a new graph
in the Query Builder.</p>
<p><img src="images/query_builder_empty.png" alt="The Query Builder tab and the Create Node button" /></p>
<p>In each node you create you may click on <img src="images/list-add.png" alt="The Add Node button" /> to specify an
annotation value. The annotation name can be typed in or selected from a drop down list once a corpus is
selected. The operator field in the middle allows you to choose between
an exact match (the '=' symbol) or wildcard search using Regular
Expressions (the '~' symbol). The annotation value is given on the
right, and should <strong>NOT</strong> be surrounded by quotations (see the example
below). It is also possible to specify multiple annotations applying to
the same position by clicking on <img src="images/list-add.png" alt="The Add Node button" />
multiple times. Clicking on <img src="images/edit-clear.png" alt="The Clear all nodes button" />
will delete the values in the node. To search
for word forms, simply choose &quot;tok&quot; as the field name on the left. A
node with no data entered will match any node, that is an underspecified
token or non-terminal node or annotation.</p>
<p><img src="images/node.png" alt="Query Builder node" /></p>
<p>To specify the relationship between nodes, first click on the &quot;Edge&quot;
link at the top left of one node, and then click the &quot;Dock&quot; link which
becomes available on the other nodes. An edge will connect the nodes
with an extra box from which operators may be selected (see below). For
operators allowing additional labels (e.g. the dominance operator <code>&gt;</code>
allows edge labels to be specified), you may type directly into the
edge's operator box, as in the example with a &quot;func&quot; label in the
image below. Note that the node clicked on first (where the &quot;Edge&quot;
button was clicked) will be the first node in the resulting quey, i.e.
if this is the first node it will dominate the second node (<code>#1 &gt; #2</code>)
and not the other way around, as also represented by the arrows along
the edge.</p>
<p><img src="images/edge.png" alt="Connecting nodes with an edge" /></p>
<a class="header" href="#annis-query-language-aql" id="annis-query-language-aql"><h1>ANNIS Query Language (AQL)</h1></a>
<p>ANNIS comes with its own query language called ANNIS Query Language (AQL).
AQL is based on the concept of searching for annotation attributes and relations between them.</p>
<a class="header" href="#searching-for-word-forms" id="searching-for-word-forms"><h1>Searching for Word Forms</h1></a>
<p>To search for word forms in ANNIS, simply select a corpus (in this
example the freely available <a href="https://corpling.uis.georgetown.edu/gum/">GUM corpus</a>) and enter a search string
between double quotation marks, e.g.:</p>
<pre><code>&quot;do&quot;
</code></pre>
<p>Note that the search is <strong>case sensitive</strong>, so it will not find cases of
capitalized 'Do', for example at the beginning of a sentence. In order
to find both options, you can either look for one form OR the other
using the pipe sign ( <code>|</code> ):</p>
<pre><code>&quot;do&quot; | &quot;Do&quot;
</code></pre>
<p>or else you can use <a href="aql-regex.html">regular expressions</a>, which must
be surrounded by slashes ( <code>/</code> ) instead of quotation marks:</p>
<pre><code>/[Dd]o/
</code></pre>
<p>To look for a sequence of multiple word forms, enter your search terms
separated by <code>&amp;</code> and then specify that the relation between the elements
is one of <strong>precedence</strong>, as signified by the period ( <strong><code>.</code></strong> )
operator:</p>
<pre><code>&quot;do&quot; &amp; &quot;n't&quot; &amp; #1 . #2
</code></pre>
<p>The expression <code>#1 . #2</code> signifies that the first element (&quot;do&quot;)
precedes the second element (&quot;n't&quot;). Alternatively, you can also place
the operator directly between the search elements as a <strong>shortcut</strong>. The
following shortcut query is equivalent to the one above:</p>
<pre><code>&quot;do&quot; . &quot;n't&quot;`
</code></pre>
<p>For <strong>indirect precedence</strong> (where other tokens may stand between the
search terms), use the <strong><code>.*</code></strong> operator:</p>
<pre><code>/[Dd]o/ &amp; &quot;n't&quot; &amp; &quot;any&quot; &amp; #1 . #2 &amp; #2 .* #3 
</code></pre>
<p><strong>OR using shortcuts:</strong></p>
<pre><code>/[Dd]o/ . &quot;n't&quot; .* &quot;any&quot;
</code></pre>
<p>The queries above find sequences beginning with the token &quot;Do&quot; or &quot;do&quot;,
followed directly by &quot;n't&quot;, which must be followed either directly or
indirectly (.*) by &quot;any&quot;. A range of allowed distances can also be
specified numerically as follows:</p>
<pre><code>/[Nn]ot/ &amp; &quot;all&quot; &amp; #1 .1,5 #2
</code></pre>
<p><strong>OR:</strong></p>
<pre><code>/[Nn]ot/ .1,5 &quot;all&quot;
</code></pre>
<p>Meaning the two words &quot;not&quot; and &quot;all&quot; may appear at a distance of 1 to 5
tokens. The operator <code>.*</code> allows a distance of up to 50 tokens by
default, so searching with <code>.1,50</code> is the same as using <code>.*</code> instead.
Greater distances (e.g. <code>.1,100</code> for 'within 100 tokens') should always
be specified explicitly.</p>
<p>Finally, we can add metadata restrictions to the query, which filter out
documents not matching our definitions. Metadata attributes must be
preceded by the prefix meta:: and may not be bound (i.e. they are not
referred to as #1 etc. and the numbering of other elements ignores
their existence):</p>
<pre><code>&quot;want&quot; &amp; &quot;to&quot; &amp; #1 .1,5 #2 &amp; meta::type=&quot;interview&quot; 
</code></pre>
<p>To view metadata for a search result or for a corpus, press the &quot;i&quot; icon
next to it in the result window or in the search form respectively.</p>
<a class="header" href="#searching-for-annotations" id="searching-for-annotations"><h1>Searching for Annotations</h1></a>
<p>Annotations may be searched for using an annotation name and value. The
names of the annotations vary from corpus to corpus, though many corpora
contain part-of-speech and lemma annotations with the names <code>pos</code> and
<code>lemma</code> respectively (annotation names are <strong>case sensitive</strong>). For
example, to search for all forms of the verb <em>be</em> in the GUM corpus,
simply select the GUM corpus and enter:</p>
<pre><code>lemma=&quot;be&quot;
</code></pre>
<p>Negative searches are also possible using != instead of =. For negated
tokens (word forms) use the reserved attribute tok. For example:</p>
<pre><code>lemma!=&quot;be&quot;
</code></pre>
<p>or:</p>
<pre><code>tok!=&quot;be&quot; 
</code></pre>
<p>Metadata can also be negated similarly:</p>
<pre><code>lemma=&quot;be&quot; &amp; meta::type!=&quot;interview&quot;
</code></pre>
<p>To only find finite forms of a verb in GUM, use the part-of-speech (pos)
annotation concurrently with lemma, and specify that both the lemma and
pos should apply to the same element. For example for inflected forms of
the verb <em>give</em>:</p>
<pre><code>lemma=&quot;give&quot; &amp; pos=/VV.+/ &amp; #1 _=_ #2
</code></pre>
<p>OR (using a shortcut):</p>
<pre><code>lemma=&quot;give&quot; _=_ pos=/VV.+/
</code></pre>
<p>The regular expression <code>/VV.+/</code> means a part of speach that begins with
VV (verb), but has additional characters (.+), such as for past tense
(VVD) or gerund (VVG). The expression <code>#1 _=_ #2</code> uses the span identity
operator to specify that the first annotation and the second annotation
apply to exactly the same position in the corpus.</p>
<p>Annotations can also apply to longer spans than a single token: for
example, in GUM, the annotation <code>entity</code> signifies the entity type of a
discourse referent. This annotation can also apply to phrases longer
than one token. The following query finds spans containing a discourse
referent who is a person:</p>
<pre><code>entity=&quot;person&quot;
</code></pre>
<p>If the corpus contains more than one annotation type named <code>entity</code>, a
namespace may be added to disambiguate these annotations (for example,
the entity annotation in the GUM corpus has the namespace <code>ref:</code>, so we
can search for <code>ref:entity=&quot;person&quot;</code>). The namespace may always be
dropped, but if there are multiple annotations with the same name but
different namespaces, dropping the namespace will find all of those
annotations. If you drop the value of the annotation, you can also
search for any corpus positions that have that annotation, without
constraining the value. For example, the following query finds all
annotated entities in the GUM corpus, whether or not they are a person:</p>
<pre><code>entity
</code></pre>
<p>In order to view the span of tokens to which the entity annotation
applies, enter the query and click on &quot;Search&quot;, then open the
<em>referents</em> layer to view the grid containing the span.</p>
<p>Further operators can test the relationships between potentially
overlapping annotations in spans. For example, the operator <code>_i_</code>
examines whether one annotation fully contains the span of another
annotation (the <em>i</em> stands for 'includes'):</p>
<pre><code>head &amp; infstat=&quot;new&quot; &amp; #1 _i_ #2
</code></pre>
<p>OR (using a shortcut):</p>
<pre><code>head _i_ infstat=&quot;new&quot;
</code></pre>
<p>This query finds information structurally new discourse referents
(<code>infstat=&quot;new&quot;</code>) contained within headings (<code>head</code>).</p>
<a class="header" href="#searching-using-regular-expressions" id="searching-using-regular-expressions"><h1>Searching using Regular Expressions</h1></a>
<p>When searching for word forms and annotation values, it is possible to
employ wildcards as placeholders for a variety of characters, using
Regular Expression syntax (see
<a href="http://www.regular-expressions.info/">here</a> for detailed information).
To search for wildcards use slashes instead of quotation marks to
surround your search term. For example, you can use the <strong>period (<code>.</code>)</strong>
to replace any single character:</p>
<pre><code>tok=/ca./
</code></pre>
<p>This finds word forms such as &quot;cat&quot;, &quot;can&quot;, &quot;car&quot;, &quot;cap&quot; etc. It is also
possible to make characters optional by following them with a <strong>question
mark (<code>?</code>)</strong>. The following example finds cases of &quot;car&quot; and &quot;cart&quot;,
since the &quot;t&quot; is optional:</p>
<pre><code>tok=/cart?/
</code></pre>
<p>It is also possible to specify an arbitrary number of repetitions, with
an <strong>asterisk (<code>*</code>)</strong> signifying zero or more occurrences and a <strong>plus
(<code>+</code>)</strong> signifying at least one occurrence. For example, the first query
below finds &quot;o&quot;, &quot;of&quot;, and &quot;off&quot; (since the asterisk means zero or more
times the preceding &quot;f&quot;), while the second finds &quot;of&quot; and &quot;off&quot;, since
at least one &quot;f&quot; must be found:</p>
<pre><code>tok=/of*/
</code></pre>
<pre><code>tok=/of+/
</code></pre>
<p>It is possible to combine these operators with the period operator to
mean any number of occurrences of an arbitrary character. For example,
the query below searches for pos (part-of-speech) annotations that begin
with &quot;VV&quot;, corresponding to all forms of lexical verbs (the auxiliaries
&quot;be&quot; and &quot;have&quot; are tagged VB... and VH... respectively). The string
&quot;VV&quot; means that the result must begin with &quot;VV&quot;, the period stands for
any character, and the asterisk means that 'any character' can be
repeated zero or more time, as above.</p>
<pre><code>pos=/VV.*/
</code></pre>
<p>This finds both finite verbs (&quot;VVZ&quot;, &quot;VVP&quot;, &quot;VVD&quot;) and non-finite ones
(&quot;VV&quot;) or gerunds (&quot;VVG&quot;). It is also possible to search for explicit
alternatives by either specifying characters in <strong>square brackets</strong> or
longer strings in <strong>round brackets separated by pipe symbols</strong>. The
first example below finds either &quot;of&quot; or &quot;on&quot; (i.e. &quot;o&quot; followed by
either &quot;f&quot; or &quot;n&quot;) while the second example finds lemma annotations that
are either &quot;be&quot; or &quot;have&quot;.</p>
<pre><code>tok=/o[nf]/
</code></pre>
<pre><code>lemma=/(be|have)/
</code></pre>
<p>Finally, negative searches can be used as usual with the exclamation
point, and regular expressions can generally be used also in edge
annotations. For example, if we search for trees (see also <a href="aql-trees.html">Searching
for Trees</a>) where a lexical verb dominates another
token with a dependency edge not containing 'obj', we can use a wildcard
to rule out all edges labels containing those letters. This will give us
all non-object dependants of lexical verbs:</p>
<pre><code>pos=/VV.*/ &amp; tok &amp; #1 -&gt;dep[func!=/.*obj.*/] #2
</code></pre>
<p>OR (using a shortcut):</p>
<pre><code>pos=/VV.*/ -&gt;dep[func!=/.*obj.*/] tok
</code></pre>
<a class="header" href="#searching-for-trees" id="searching-for-trees"><h1>Searching for Trees</h1></a>
<p>In corpora containing hierarchical structures, annotations such as
syntax trees can be searched for by defining terminal or none-terminal
node annotations, functional dependencies and their values (for
dependencies see see <a href="aql-pointing.html">Searching for Pointing
Relations</a>). A simple search for
prepostional phrases in the GUM corpus looks like this:</p>
<pre><code>const:cat=&quot;PP&quot;
</code></pre>
<p>If the corpus contains no more than one annotation called <code>cat</code>, the
optional namespace, in this case <code>const:</code>, may be dropped. This finds
all PP nodes in the corpus. You can also search for the NP being
dominated by the PP like this:</p>
<pre><code>cat=&quot;PP&quot; &amp; cat=&quot;NP&quot; &amp; #1 &gt; #2
</code></pre>
<p>OR (using a shortcut):</p>
<pre><code>cat=&quot;PP&quot; &gt; cat=&quot;NP&quot;
</code></pre>
<p>To find all PP nodes directly dominating an adverb, you can combine a
search for syntactic category and part-of-speech (pos) values (in this
case &quot;RB&quot; for adverb). The query below gives the shortcut form:</p>
<pre><code>cat=&quot;PP&quot; &gt; pos=&quot;RB&quot;
</code></pre>
<p>The operator <strong>&gt;</strong> signifies <strong>direct dominance</strong>, which must hold
between the first and the second element. Once the Query Result tab is
shown you may open the &quot;constituents&quot; annotation layer to see the
corresponding tree.</p>
<p><img src="images/tree_expanded.png" alt="" /></p>
<p>Note that since the context is set to a number of tokens left and right
of the search term, the tree for the whole sentence may not be
retrieved, though you can change the amount of tokens at the top of each
search result, or for all search results in the Search Options tab. To
make sure that the whole clause is always included, you may want to
specifically search for the clause or sentence dominating the PP. To do
so, specify the sentence in another element and use the <strong>indirect
dominance</strong> ( <strong>&gt;*</strong> ) operator:</p>
<pre><code>cat=&quot;ROOT&quot; &gt;* cat=&quot;PP&quot; &gt; pos=&quot;RB&quot;
</code></pre>
<p>If the annotations in the corpus support it, you may also look for edge
labels. Using the following query will find all adverbial modifier NPs,
dominated by some node through an edge labeled ADV. Since we do not know
anything about the modified node, we simply use the <code>node</code> element as a
place holder. This element can match any node or annotation in the
graph:</p>
<pre><code>node &gt;[const:func=&quot;ADV&quot;] cat=&quot;NP&quot;
</code></pre>
<p>Again, the namespace <code>const:</code> is optional and only important if there
are multiple 'func' annotations. It is also possible to negate the label
of the dominance edge as in the following query:</p>
<pre><code>cat &gt;[func!=&quot;TMP&quot;] cat
</code></pre>
<p>which finds all syntactic categories (value unspecified) dominating
another syntactic category with a label other than &quot;TMP&quot;.</p>
<a class="header" href="#searching-for-pointing-relations" id="searching-for-pointing-relations"><h1>Searching for Pointing Relations</h1></a>
<p>Pointing relations are used to express an arbitrary directed
relationship between two elements (terminals or non-terminals) without
implying dominance or coverage inheritance. For instance, in the GUM
corpus, elements in the <code>ref:</code> namespace may point to each other to
express coreference or anaphoric relations. The following query searches
for two <code>entity</code> annotations, which specify whether a discourse referent
is a person, or an animal, a location, an object, an abstract etc.</p>
<pre><code>entity=&quot;person&quot; &amp; entity!=&quot;person&quot; &amp; #1 -&gt;coref #2
</code></pre>
<p>Using the pointing relation operator <code>-&gt;</code> with the type <code>coref</code>, the
first <code>entity</code>, which should be a person, is said to be coreferent with
its antecedent, the second entity, which is not a person. In practice,
this will usually occur due to &quot;bridging&quot;, where something like a whole
(e.g. an organization such as a 'research team') implies the existence
of its part (e.g. persons, such as 'the scientists'). To see a
visualization of the coreference relations, open the coreference
annotation layer in the GUM corpus. In the image below, one of the
matches for the above query is highlighted in red (die Seeburger und
einige Groß-Glienicker ... sie 'the Seeburgers and some
Groß-Glienickers... they'). Other discourse referents in the text
(marked with an underline) may be clicked on, causing coreferential
chains containing them to be highlighted as well. Note that discourse
referents may overlap, leading to multiple underlines: Die Seeburger
'the Seeburgers' is a shorter discourse referent overlapping with the
larger one ('the Seeburgers and some Groß-Glienickers'), and each
referent has its own underline. Annotations of the coreference edges of
each relation can be viewed by hovering of the appropriate underline.</p>
<p><img src="images/coref.png" alt="" /></p>
<p>The pointing relation operator can also search for longer chains of
coreference, using the asterisk extension shown below:</p>
<pre><code>entity=&quot;organization&quot; -&gt;coref* entity=&quot;person&quot;
</code></pre>
<p>This finds all organizations that point back to a person at any point
along the preceding coreference chain. It is also possible to specify
annotations of pointing relations, which for coreference in the GUM
corpus mark what kind of coreference is used: anaphoric, cataphoric,
lexical coreference, apposition, or bridging. To find appositions of
place entities, use the following query:</p>
<pre><code>entity=&quot;place&quot; -&gt;coref[type=&quot;appos&quot;] entity=&quot;place&quot;
</code></pre>
<p>Another way to use pointing relations is found in syntactic dependency
trees. The queries in this case can use both pointing relation types and
annotations too, as in the following query:</p>
<pre><code>pos=/VV[PZ]/ &amp; tok &amp; #1 -&gt;dep[func=&quot;dobj&quot;] #2
</code></pre>
<p>OR (using a shortcut):</p>
<pre><code>pos=/VV[PZ]/ -&gt;dep[func=&quot;dobj&quot;] tok
</code></pre>
<p>This query searches for a present tense lexical verb (with the
part-of-speech VVZ or VVP) and a token, with a pointing relation of the
type 'dep' (for dependency) between the two, annotated with
<code>func=&quot;dobj&quot;</code> (the function 'direct object'). The result can be viewed
with the arch dependency visualizer, which shows the verb 'shows' and
its object 'location'.</p>
<p><img src="images/dep_vis.png" alt="" /></p>
<a class="header" href="#exporting-results" id="exporting-results"><h1>Exporting Results</h1></a>
<p>To export search results, open the menu &quot;More&quot; between the Search and
History buttons and select &quot;Export&quot;:</p>
<p><img src="images/export.png" alt="" /></p>
<p>Enter the query whose results you want to export as usual in the AQL
box. Note that you <strong>do not need to carry out the query first</strong>. You can
enter the query and export without pressing Search before. Several
exporter modules can be selected from the Export tab shown below.</p>
<p><img src="images/export2.png" alt="" /></p>
<p>The SimpleTextExporter simply gives the text for all tokens in each
search result, including context, in a one-row-per-hit format. The
tokens covered by the match area are marked with square brackets and the
results are numbered, as in the following
example:</p>
<pre><code>    0. of the International Brotherhood of [Magicians] Wednesday , October 9 , 
    1. Magic Month in the United [States] . Wikinews spoke with William 
    2. of the International Brotherhood of [Magicians] , about the current state 
    3. - &quot; Scarne on Card [Tricks] &quot; and &quot; Scarne on 
    4. and &quot; Scarne on Magic [Tricks] &quot; . That started me 
</code></pre>
<p>The TextExporter adds all annotations of each token separated by slashes
(e.g. dogs/NNS/dog for a token dogs annotated with a part-of-speech NNS
and a lemma dog).</p>
<p>The GridExporter adds all annotations available for the span of
retrieved tokens, with each annotation layer in a separate line.
Annotations are separated by spaces and the hierarchical order of
annotations is lost, though the span of tokens covered by each
annotation may optionally be given in square brackets (to turn this off
use the optional parameter <code>numbers=false</code> in the ‘Parameters’ box). The
user can specify annotation layers to be exported in the additional
‘Annotation Keys’ box, and annotation names should be separated by
comas, as in the image above. Metadata annotations can also be exported
by entering “metakeys=” and a list of comma separated metadata names in
the Parameters box. If nothing is specified, all available annotations
and no metadata will be exported. Multiple options are separated by a
semicolon, e.g. the Parameters <code>metakeys=type,docname;numbers=false</code>. An
example output with token numbers and the part of speech (pos) and
syntactic category annotations looks as follows.</p>
<pre><code>0.   tok  of the International Brotherhood of Magicians Wednesday 
    pos  IN[1-1] DT[2-2] NP[3-3] NP[4-4] IN[5-5] NPS[6-6] NP[7-7] 
    cat  S[1-6] VP[1-6] NP[1-6] PP[1-6] NP[2-4] PP[5-6] NP[6-6] NP[7-12] 
</code></pre>
<p>Meaning that the annotation cat=&quot;NP&quot; applies to tokens 1-6 in the search
result, and so on. Note that when specifying annotation layers, if the
reserved name 'tok' is not specified, the tokens themselves will not be
exported (annotations only).</p>
<p>The WekaExporter outputs the format used by the <a href="http://www.cs.waikato.ac.nz/ml/weka/">WEKA machine learning
tool</a>. Only the attributes of the
search elements (#1, #2 etc. in AQL) are outputted, and are separated
by commas. The order and name of the attributes is declared in the
beginning of the export text, as in this example:</p>
<pre><code>@relation name

@attribute #1_id string
@attribute #1_span string
@attribute #1_anno_const:cat string
@attribute #2_id string
@attribute #2_span string
@attribute #2_anno_GUM:claws5 string
@attribute #2_anno_GUM:lemma string
@attribute #2_anno_GUM:pos string

@data

'11318611','the current state','NP','11318616','current','AJ0','current','JJ'
'11318686','magic','NP','11318688','magic','AJ0','magic','JJ'
'11318757','some basic tricks','NP','11318760','basic','AJ0','basic','JJ'
</code></pre>
<p>The export shows the properties of an NP node dominating a token with
the part-of-speech JJ. Since the token also has other attributes, such
as the lemma and part of speech tags, these are also retrieved.</p>
<p>It is also possible to output metadata annotations per hit using the
WekaExporter. To do so, use the parameter metakeys=meta1,meta2 etc. For
example, if your documents have a metadata annotation called 'genre',
you may export it for each search result as a further column using
metakeys=genre in the parameters box.</p>
<p>The CSVExporter behaves much like the WekaExporter, except that the Weka
header specifying the content of the columns is not used (useful for
importing into spreadsheet programs such as Excel or Calc).</p>
<p>Note that exporting may be slow if the result set is large.</p>
<a class="header" href="#frequency-analysis" id="frequency-analysis"><h1>Frequency Analysis</h1></a>
<p>To perform a frequency analysis, enter the query whose results you want
to analyze as usual in the AQL box. Note that you <strong>do not need to carry
out the query first</strong>. Next, open the menu “More” between the Search and
History buttons and select “Frequency Analysis”:</p>
<p><img src="images/export.png" alt="" /></p>
<p>The interface will open the frequency analysis tab shown below.
Initially, rows will be generated for the nodes present in the query.
For example, two rows are automatically generated for the following
query, which finds any pair of consecutive tokens:</p>
<pre><code>tok . tok
</code></pre>
<p><img src="images/freq.png" alt="" /></p>
<p>You may also add metadata to the frequency breakdown from the metadata
selection link. Clicking on “Perform frequency analysis” will produce a
breakdown of all consecutive token bigrams in the corpus. The frequency
graph will only show the first 500 elements, but the table below it will
give the entire list of values, which can also be <strong>exported as a CSV
file</strong>.</p>
<p><img src="images/freq2.png" alt="" /></p>
<p>To edit the analysis or analyze a new query, click the <strong>New Analysis</strong>
button. It is also possible to <strong>add annotations</strong> to the analysis that
were not in the original query, provided that these are expected to
belong to some other node in the query. For example, the tokens in the
GUM corpus also have part-of-speech and lemma information. We can
replace the lines in the analysis specifying that tok values should be
counted with pos values, which gives us part-of-speech bigrams. We can
also add a lemma annotation belonging to the first search element, by
clicking the Add button and entering the node definition number and
annotation name we are interested in:</p>
<p><img src="images/freq3.png" alt="" /></p>
<p>As a result, we will get a count for each combination of values grouped
by the first and second tokens' parts-of-speech, as well as the first
token's lemma.</p>
<a class="header" href="#complete-list-of-operators" id="complete-list-of-operators"><h1>Complete List of Operators</h1></a>
<p>AQL currently includes the following operators:</p>
<table><thead><tr><th align="center"> Operator          </th><th align="left"> Description                </th><th align="center"> Illustration                                    </th><th align="left"> Notes                                                                                                                                                                                                                                       </th></tr></thead><tbody>
<tr><td align="center"> <code>.</code>               </td><td align="left"> direct precedence          </td><td align="center"> <img src="images/A-pred-B.svg" alt="" />                               </td><td align="left"> For non-terminal nodes, precedence is determined by the right-most and left-most terminal children. In corpora with multiple segmentations the layer on which consecutivity holds may be specified with <code>.layer</code>                            </td></tr>
<tr><td align="center"> <code>.*</code>              </td><td align="left"> indirect precedence        </td><td align="center"> <img src="images/A-pred-ind-B.svg" alt="" />                           </td><td align="left"> For specific sizes of precedence spans, <code>.n,m</code> can be used, e.g. <code>.3,4</code> - between 3 and 4 token distance; the default maximum distance for <code>.*</code> is 50 tokens. As above, segmentation layers may be specified, e.g. <code>.layer,3,4</code>             </td></tr>
<tr><td align="center"> <code>^</code>               </td><td align="left"> directly near              </td><td align="center"> <img src="images/A-pred-B.svg" alt="" /> or <img src="images/B-pred-A.svg" alt="" />          </td><td align="left"> Same as precedence, but in either order. In corpora with multiple segmentations the layer on which consecutivity holds may be specified with <code>^layer</code>                                                                                       </td></tr>
<tr><td align="center"> <code>^*</code>              </td><td align="left"> indirectly near            </td><td align="center"> <img src="images/A-pred-ind-B.svg" alt="" /> or <img src="images/B-pred-ind-A.svg" alt="" />  </td><td align="left"> Like indirect precedence in either order. The form <code>^n,m</code> can be used, e.g. <code>^3,4</code> - between 3 and 4 token distance; the default maximum distance for <code>^*</code> is 50 tokens. As above, segmentation layers may be specified, e.g. <code>^layer,3,4</code>  </td></tr>
<tr><td align="center"> <code>&gt;</code>               </td><td align="left"> direct dominance           </td><td align="center"> <img src="images/A-dom-B.svg" alt="" />                                </td><td align="left"> A specific edge type may be specified, e.g. <code>&gt;secedge</code> to find secondary edges. Edge labels are specified in brackets, e.g. <code>&gt;[func=&quot;OA&quot;]</code> for an edge with the function 'object, accusative'                                               </td></tr>
<tr><td align="center"> <code>&gt;*</code>              </td><td align="left"> indirect dominance         </td><td align="center"> <img src="images/A-dom-ind-B.svg" alt="" />                            </td><td align="left"> For specific distance of dominance, <code>&gt;n,m</code> can be used, e.g. <code>&gt;3,4</code> - dominates with 3 to 4 edges distance                                                                                                                                  </td></tr>
<tr><td align="center"> <code>_=_</code>             </td><td align="left"> identical coverage         </td><td align="center"> <img src="images/A-cov-ident-B.svg" alt="" />                          </td><td align="left"> Applies when two annotations cover the exact same span of tokens                                                                                                                                                                            </td></tr>
<tr><td align="center"> <code>_i_</code>             </td><td align="left"> inclusion                  </td><td align="center"> <img src="images/A-cov-incl-B.svg" alt="" />                           </td><td align="left"> Applies when one annotation covers a span identical to or larger than  another                                                                                                                                                              </td></tr>
<tr><td align="center"> <code>_o_</code>             </td><td align="left"> overlap                    </td><td align="center"> <img src="images/A-cov-over-B.svg" alt="" />                           </td><td align="left"> For overlap only on the left or right side, use <code>_ol_</code> and <code>_or_</code> respectively                                                                                                                                                              </td></tr>
<tr><td align="center"> <code>_l_</code>             </td><td align="left"> left aligned               </td><td align="center"> <img src="images/A-cov-left-B.svg" alt="" />                           </td><td align="left"> Both elements span an area beginning with the same token                                                                                                                                                                                    </td></tr>
<tr><td align="center"> <code>_r_</code>             </td><td align="left"> right aligned              </td><td align="center"> <img src="images/A-cov-right-B.svg" alt="" />                          </td><td align="left"> Both elements span an area ending with the same token                                                                                                                                                                                       </td></tr>
<tr><td align="center"> <code>==</code>              </td><td align="left"> value identity             </td><td align="center"> <strong>A = B</strong>                                       </td><td align="left"> The value of the annotation or token A is identical to that of B (this operator does not bind, i.e. the nodes must be connected by some other criteria too)                                                                                 </td></tr>
<tr><td align="center"> <code>!=</code>              </td><td align="left"> value difference           </td><td align="center"> <strong>A ≠ B</strong>                                       </td><td align="left"> The value of the annotation or token A is different from B (this operator does not bind, i.e. the nodes must be connected by some other criteria too)                                                                                       </td></tr>
<tr><td align="center"> <code>-&gt;LABEL</code>         </td><td align="left"> labeled pointing relation  </td><td align="center"> <img src="images/A-point-direct-B.svg" alt="" />                       </td><td align="left"> A labeled, directed relationship between two elements. Annotations can be specified with <code>-&gt;LABEL[annotation=&quot;VALUE&quot;]</code>                                                                                                                      </td></tr>
<tr><td align="center"> <code>-&gt;LABEL *</code>       </td><td align="left"> indirect pointing relation </td><td align="center"> <img src="images/A-point-ind-B.svg" alt="" />                          </td><td align="left"> An indirect labeled relationship between two elements. The length of the chain may be specified with <code>-&gt;LABEL n,m</code> for relation chains of length n to m                                                                                     </td></tr>
<tr><td align="center"> <code>&gt;@l</code>             </td><td align="left"> left-most child            </td><td align="center"> <img src="images/A-left-B.svg" alt="" />                               </td><td align="left">                                                                                                                                                                                                                                             </td></tr>
<tr><td align="center"> <code>&gt;@r</code>             </td><td align="left"> right-most child           </td><td align="center"> <img src="images/A-right-B.svg" alt="" />                              </td><td align="left">                                                                                                                                                                                                                                             </td></tr>
<tr><td align="center"> <code>$</code>               </td><td align="left"> common parent node         </td><td align="center"> <img src="images/A-parent-B.svg" alt="" />                             </td><td align="left">                                                                                                                                                                                                                                             </td></tr>
<tr><td align="center"> <code>$*</code>              </td><td align="left"> common ancestor node       </td><td align="center"> <img src="images/A-ancestor-B.svg" alt="" />                          </td><td align="left">                                                                                                                                                                                                                                             </td></tr>
<tr><td align="center"> <code>#x:arity=n</code>      </td><td align="left"> arity                      </td><td align="center"> <img src="images/A-arity.svg" alt="" />                               </td><td align="left"> Specifies the amount of directly dominated children that the searched node has                                                                                                                                                              </td></tr>
<tr><td align="center"> <code>#x:tokenarity=n</code> </td><td align="left"> tokenarity                 </td><td align="center"> <img src="images/A-tokenarity.svg" alt="" />                           </td><td align="left"> Specifies the length of the span of tokens covered by the node                                                                                                                                                                              </td></tr>
<tr><td align="center"> <code>#x:root</code>         </td><td align="left"> root                       </td><td align="center"> <img src="images/A-root.svg" alt="" />                                 </td><td align="left"> Specifies that the node is not dominated by any other node within its namespace                                                                                                                                                             </td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
